"""
Gendered Temporal Vulnerability Analysis
=========================================

Research Question: Does male-specific vulnerability emerge early or late
in the task session? Is it stable or progressive?

Tests UCLA × Gender × Epoch three-way interaction.
"""

from __future__ import annotations
import sys
import warnings
from pathlib import Path

sys.path.insert(0, str(Path(__file__).resolve().parent.parent))

import numpy as np
import pandas as pd
import statsmodels.formula.api as smf
from scipy import stats

try:
    import pymc as pm
    HAS_PYMC = True
except ImportError:
    HAS_PYMC = False

if sys.platform.startswith("win") and hasattr(sys.stdout, "reconfigure"):
    sys.stdout.reconfigure(encoding='utf-8')

from analysis.utils.data_loader_utils import load_master_dataset, ANALYSIS_OUTPUT_DIR
from analysis.utils.trial_data_loader import load_wcst_trials, load_stroop_trials

OUTPUT_DIR = ANALYSIS_OUTPUT_DIR / "temporal_vulnerability"
OUTPUT_DIR.mkdir(parents=True, exist_ok=True)


def compute_epoch_metrics(trial_df: pd.DataFrame, metric_col: str, task_name: str) -> pd.DataFrame:
    """
    Divide trials into thirds (early/middle/late) and compute metrics per epoch.
    """
    results = []

    for pid, grp in trial_df.groupby("participant_id"):
        grp = grp.sort_values(grp.columns[0]).reset_index(drop=True)
        n_trials = len(grp)

        if n_trials < 30:
            continue

        # Divide into thirds
        third = n_trials // 3
        epochs = {
            "early": grp.iloc[:third],
            "middle": grp.iloc[third:2*third],
            "late": grp.iloc[2*third:],
        }

        result = {"participant_id": pid}

        for epoch_name, epoch_df in epochs.items():
            if metric_col in epoch_df.columns:
                val = epoch_df[metric_col].mean() if epoch_df[metric_col].dtype in ['float64', 'int64', 'bool'] else \
                      epoch_df[metric_col].fillna(False).astype(float).mean()
                result[f"{task_name}_{epoch_name}"] = val

        # Compute slope (late - early)
        if f"{task_name}_early" in result and f"{task_name}_late" in result:
            result[f"{task_name}_slope"] = result[f"{task_name}_late"] - result[f"{task_name}_early"]

        results.append(result)

    return pd.DataFrame(results)


def run_threeway_interaction(master_df: pd.DataFrame, outcomes: list) -> pd.DataFrame:
    """
    Test UCLA × Gender × Epoch interaction.
    """
    results = []

    for task in ["wcst", "stroop"]:
        epochs = ["early", "middle", "late"]
        epoch_cols = [f"{task}_{e}" for e in epochs]

        # Check if all columns exist
        if not all(c in master_df.columns for c in epoch_cols):
            continue

        # Reshape to long format (filter missing DASS values instead of default=0)
        long_data = []
        required_cols = ["z_ucla", "gender_male", "z_dass_depression", "z_dass_anxiety", "z_dass_stress", "z_age"]
        for _, row in master_df.iterrows():
            # Skip if any required covariate is missing
            if any(pd.isna(row.get(c)) for c in required_cols):
                continue
            for epoch in epochs:
                col = f"{task}_{epoch}"
                if col in row and pd.notna(row[col]):
                    long_data.append({
                        "participant_id": row["participant_id"],
                        "epoch": epoch,
                        "value": row[col],
                        "z_ucla": row["z_ucla"],
                        "gender_male": row["gender_male"],
                        "z_dass_depression": row["z_dass_depression"],
                        "z_dass_anxiety": row["z_dass_anxiety"],
                        "z_dass_stress": row["z_dass_stress"],
                        "z_age": row["z_age"],
                    })

        if len(long_data) < 50:
            continue

        long_df = pd.DataFrame(long_data)
        long_df["epoch_num"] = long_df["epoch"].map({"early": 0, "middle": 1, "late": 2})

        # Ensure gender is numeric (0/1)
        long_df["gender_male"] = long_df["gender_male"].astype(float)

        # Full model with three-way interaction
        try:
            # Use simpler formula without C() to avoid index errors
            formula = "value ~ z_ucla * gender_male * epoch_num + z_dass_depression + z_dass_anxiety + z_dass_stress + z_age"

            with warnings.catch_warnings():
                warnings.simplefilter("ignore")
                model = smf.mixedlm(formula, long_df, groups=long_df["participant_id"]).fit(method="powell")

            for param in model.params.index:
                if param in ["Group Var", "Intercept"]:
                    continue
                results.append({
                    "task": task,
                    "parameter": param,
                    "coefficient": model.params[param],
                    "std_error": model.bse.get(param, np.nan) if hasattr(model.bse, 'get') else model.bse[param] if param in model.bse.index else np.nan,
                    "z_value": model.tvalues.get(param, np.nan) if hasattr(model.tvalues, 'get') else model.tvalues[param] if param in model.tvalues.index else np.nan,
                    "p_value": model.pvalues.get(param, np.nan) if hasattr(model.pvalues, 'get') else model.pvalues[param] if param in model.pvalues.index else np.nan,
                })
        except Exception as e:
            print(f"  Error in three-way model for {task}: {e}")
            # Fallback: try simpler two-way interaction model
            try:
                formula_simple = "value ~ z_ucla * gender_male + epoch_num + z_dass_depression + z_dass_anxiety + z_dass_stress + z_age"
                with warnings.catch_warnings():
                    warnings.simplefilter("ignore")
                    model = smf.mixedlm(formula_simple, long_df, groups=long_df["participant_id"]).fit(method="powell")

                for param in model.params.index:
                    if param in ["Group Var", "Intercept"]:
                        continue
                    results.append({
                        "task": task,
                        "parameter": param + " (simplified)",
                        "coefficient": model.params[param],
                        "std_error": model.bse.get(param, np.nan) if hasattr(model.bse, 'get') else model.bse[param] if param in model.bse.index else np.nan,
                        "z_value": model.tvalues.get(param, np.nan) if hasattr(model.tvalues, 'get') else model.tvalues[param] if param in model.tvalues.index else np.nan,
                        "p_value": model.pvalues.get(param, np.nan) if hasattr(model.pvalues, 'get') else model.pvalues[param] if param in model.pvalues.index else np.nan,
                    })
                print(f"  Used simplified model for {task}")
            except Exception as e2:
                print(f"  Simplified model also failed for {task}: {e2}")

    return pd.DataFrame(results)


def run_epoch_regressions(master_df: pd.DataFrame, outcomes: list, outcome_labels: dict) -> pd.DataFrame:
    """Run regressions for epoch-specific outcomes."""
    results = []
    formula_template = "{outcome} ~ z_ucla * C(gender_male) + z_dass_depression + z_dass_anxiety + z_dass_stress + z_age"

    for outcome in outcomes:
        if outcome not in master_df.columns:
            continue

        df_clean = master_df.dropna(subset=[outcome, "z_ucla", "gender_male",
                                            "z_dass_depression", "z_dass_anxiety", "z_dass_stress", "z_age"])

        if len(df_clean) < 30:
            continue

        formula = formula_template.format(outcome=outcome)

        try:
            model = smf.ols(formula, data=df_clean).fit()

            for param in model.params.index:
                if param == "Intercept":
                    continue
                results.append({
                    "outcome": outcome,
                    "outcome_label": outcome_labels.get(outcome, outcome),
                    "parameter": param,
                    "coefficient": model.params[param],
                    "std_error": model.bse[param],
                    "t_value": model.tvalues[param],
                    "p_value": model.pvalues[param],
                    "n_obs": int(model.nobs),
                })
        except Exception as e:
            print(f"  Error fitting {outcome}: {e}")

    return pd.DataFrame(results)


def create_summary_report(epoch_results: pd.DataFrame, threeway_results: pd.DataFrame) -> str:
    """Generate summary report."""
    lines = [
        "=" * 80,
        "GENDERED TEMPORAL VULNERABILITY: SUMMARY REPORT",
        "=" * 80,
        "",
        "RESEARCH QUESTION:",
        "Does male-specific vulnerability emerge early or late in task session?",
        "",
    ]

    lines.extend([
        "-" * 80,
        "THREE-WAY INTERACTION (UCLA × Gender × Epoch):",
        "-" * 80,
    ])

    if not threeway_results.empty:
        sig = threeway_results[threeway_results["p_value"] < 0.05]
        if len(sig) > 0:
            for _, row in sig.iterrows():
                lines.append(f"  {row['task']}: {row['parameter']}")
                lines.append(f"    beta = {row['coefficient']:.4f}, p = {row['p_value']:.4f}")
        else:
            lines.append("  No significant three-way interactions")

    lines.extend([
        "",
        "-" * 80,
        "EPOCH-SPECIFIC UCLA EFFECTS:",
        "-" * 80,
    ])

    if not epoch_results.empty:
        ucla_effects = epoch_results[epoch_results["parameter"].str.contains("ucla", case=False)]
        for _, row in ucla_effects.iterrows():
            sig = "*" if row["p_value"] < 0.05 else ""
            lines.append(f"  {row['outcome_label']}: {row['parameter']} = {row['coefficient']:.3f}{sig}")

    lines.extend([
        "",
        "=" * 80,
        "INTERPRETATION:",
        "=" * 80,
        "",
        "If UCLA effect INCREASES across epochs:",
        "  -> Resource depletion model (fatigue-driven)",
        "",
        "If UCLA effect DECREASES across epochs:",
        "  -> Adaptation/recovery capacity",
        "",
        "If UCLA effect is STABLE:",
        "  -> Trait-like vulnerability",
        "",
        "=" * 80,
    ])

    return "\n".join(lines)


def main():
    print("=" * 60)
    print("GENDERED TEMPORAL VULNERABILITY ANALYSIS")
    print("=" * 60)

    # Load master dataset
    print("\n[1] Loading master dataset...")
    master = load_master_dataset(force_rebuild=False)
    print(f"  Master dataset: N={len(master)}")

    # Load trial data and compute epoch metrics
    print("\n[2] Computing epoch-specific metrics...")

    # WCST
    wcst_trials, _ = load_wcst_trials(force_rebuild=False)
    wcst_epoch = compute_epoch_metrics(wcst_trials, "isPE", "wcst")
    print(f"  WCST: {len(wcst_epoch)} participants with epoch metrics")

    # Stroop (using RT as metric)
    stroop_trials, _ = load_stroop_trials(force_rebuild=False)
    stroop_epoch = compute_epoch_metrics(stroop_trials, "rt", "stroop")
    print(f"  Stroop: {len(stroop_epoch)} participants with epoch metrics")

    # Merge
    analysis_df = master.copy()
    for epoch_df in [wcst_epoch, stroop_epoch]:
        if not epoch_df.empty:
            analysis_df = analysis_df.merge(epoch_df, on="participant_id", how="left")

    # Save epoch metrics
    epoch_cols = [c for c in analysis_df.columns if any(x in c for x in ["_early", "_middle", "_late", "_slope"])]
    epoch_export = analysis_df[["participant_id"] + epoch_cols].copy()
    epoch_export.to_csv(OUTPUT_DIR / "epoch_metrics.csv", index=False, encoding="utf-8-sig")

    # Run three-way interaction
    print("\n[3] Testing three-way interaction (UCLA × Gender × Epoch)...")
    threeway_results = run_threeway_interaction(analysis_df, ["wcst", "stroop"])
    if not threeway_results.empty:
        threeway_results.to_csv(OUTPUT_DIR / "threeway_interaction.csv", index=False, encoding="utf-8-sig")

        sig = threeway_results[threeway_results["p_value"] < 0.05]
        if len(sig) > 0:
            print("  Significant effects:")
            for _, row in sig.iterrows():
                print(f"    {row['task']}: {row['parameter']}, p={row['p_value']:.4f}")

    # Epoch-specific regressions
    print("\n[4] Running epoch-specific regressions...")
    outcomes = ["wcst_early", "wcst_middle", "wcst_late", "wcst_slope",
                "stroop_early", "stroop_middle", "stroop_late", "stroop_slope"]
    outcome_labels = {o: o.replace("_", " ").title() for o in outcomes}

    epoch_results = run_epoch_regressions(analysis_df, outcomes, outcome_labels)
    epoch_results.to_csv(OUTPUT_DIR / "epoch_regressions.csv", index=False, encoding="utf-8-sig")

    sig_ucla = epoch_results[(epoch_results["p_value"] < 0.05) &
                             (epoch_results["parameter"].str.contains("ucla", case=False))]
    if len(sig_ucla) > 0:
        print("  Significant UCLA effects:")
        for _, row in sig_ucla.iterrows():
            print(f"    {row['outcome_label']}: {row['parameter']}, p={row['p_value']:.4f}")
    else:
        print("  No significant epoch-specific UCLA effects")

    # Report
    print("\n[5] Generating report...")
    report = create_summary_report(epoch_results, threeway_results)
    with open(OUTPUT_DIR / "TEMPORAL_VULNERABILITY_REPORT.txt", "w", encoding="utf-8") as f:
        f.write(report)

    print("\n" + "=" * 60)
    print("GENDERED TEMPORAL VULNERABILITY ANALYSIS COMPLETE")
    print("=" * 60)


if __name__ == "__main__":
    main()
