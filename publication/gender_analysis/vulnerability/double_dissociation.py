"""
Double Dissociation Analysis
============================

Formal tests of task-specific gender dissociation patterns.

Pattern:
- Males: WCST (set-shifting) vulnerability
- Females: Stroop (inhibitory control) / DDM drift vulnerability

Source: analysis/advanced/male_vulnerability_suite.py

Statistical Corrections (2025-01):
- Dissociation test uses stacked mixed model (3-way interaction) instead of
  independent z-test, properly accounting for within-subject correlation.
- Effect sizes reported as standardized_beta (not Cohen's d) since predictor
  is continuous and standardized.
"""

from __future__ import annotations

import sys
if sys.platform.startswith("win") and hasattr(sys.stdout, "reconfigure"):
    sys.stdout.reconfigure(encoding='utf-8')

import warnings
warnings.filterwarnings('ignore')

import json
from pathlib import Path
from typing import Dict, Any
import numpy as np
import pandas as pd
from scipy import stats
import statsmodels.formula.api as smf

from publication.preprocessing import (
    apply_fdr_correction,
    find_interaction_term,
    ANALYSIS_OUTPUT_DIR,
)

from .._utils import load_gender_data
from .._constants import MIN_SAMPLE_INTERACTION

from . import OUTPUT_DIR


# =============================================================================
# HELPER: STACKED MODEL DISSOCIATION TEST
# =============================================================================

def _test_dissociation_stacked(
    df: pd.DataFrame,
    task1: str,
    task2: str,
    verbose: bool = True
) -> Dict[str, Any]:
    """
    Test dissociation using stacked mixed model with 3-way interaction.

    This properly accounts for within-subject correlation when comparing
    UCLA×Gender interaction effects across two tasks.

    Model: z_outcome ~ z_ucla * C(gender_male) * C(task) + covariates
    Random effect: participant_id

    The 3-way interaction (z_ucla × gender × task) tests whether the
    UCLA×Gender interaction differs between tasks.

    Parameters
    ----------
    df : pd.DataFrame
        Data with required columns
    task1, task2 : str
        Task outcome columns to compare
    verbose : bool
        Print progress

    Returns
    -------
    dict
        Dissociation test results including 3-way interaction statistics
    """
    # Ensure participant_id exists
    if 'participant_id' not in df.columns:
        df = df.reset_index()
        if 'participant_id' not in df.columns:
            df['participant_id'] = range(len(df))

    # Drop missing values for all required columns including z_age
    valid = df.dropna(subset=[
        'z_ucla', task1, task2, 'gender_male',
        'z_dass_dep', 'z_dass_anx', 'z_dass_str', 'z_age',
        'participant_id'
    ]).copy()

    if len(valid) < MIN_SAMPLE_INTERACTION:
        return {'error': f'Insufficient sample size (N={len(valid)})'}

    # Standardize outcomes for comparability
    z_task1 = (valid[task1] - valid[task1].mean()) / valid[task1].std()
    z_task2 = (valid[task2] - valid[task2].mean()) / valid[task2].std()

    # Create stacked (long format) data
    n = len(valid)
    stacked = pd.DataFrame({
        'participant_id': np.concatenate([valid['participant_id'].values, valid['participant_id'].values]),
        'z_ucla': np.concatenate([valid['z_ucla'].values, valid['z_ucla'].values]),
        'gender_male': np.concatenate([valid['gender_male'].values, valid['gender_male'].values]),
        'z_dass_dep': np.concatenate([valid['z_dass_dep'].values, valid['z_dass_dep'].values]),
        'z_dass_anx': np.concatenate([valid['z_dass_anx'].values, valid['z_dass_anx'].values]),
        'z_dass_str': np.concatenate([valid['z_dass_str'].values, valid['z_dass_str'].values]),
        'z_age': np.concatenate([valid['z_age'].values, valid['z_age'].values]),
        'task': [task1] * n + [task2] * n,
        'z_outcome': np.concatenate([z_task1.values, z_task2.values]),
    })

    results = {
        'task1': task1,
        'task2': task2,
        'n_participants': n,
        'n_observations': len(stacked),
        'method': 'stacked_mixed_model_3way_interaction'
    }

    try:
        # Fit mixed model with 3-way interaction
        # Note: Using mixedlm for random intercept per participant
        formula = (
            "z_outcome ~ z_ucla * C(gender_male) * C(task) + "
            "z_dass_dep + z_dass_anx + z_dass_str + z_age"
        )

        model = smf.mixedlm(
            formula,
            stacked,
            groups=stacked['participant_id']
        ).fit(method='lbfgs', maxiter=200)

        # Extract coefficients
        # Main effects and 2-way interactions
        results['converged'] = model.converged

        # Find the 3-way interaction term
        # Format: z_ucla:C(gender_male)[T.1]:C(task)[T.{task2}]
        three_way_terms = [
            p for p in model.params.index
            if 'z_ucla' in p and 'gender_male' in p and 'task' in p
        ]

        if three_way_terms:
            three_way_term = three_way_terms[0]
            beta_3way = model.params[three_way_term]
            se_3way = model.bse[three_way_term]
            z_3way = model.tvalues[three_way_term]
            p_3way = model.pvalues[three_way_term]

            results['beta_dissociation'] = float(beta_3way)
            results['se_dissociation'] = float(se_3way)
            results['z_dissociation'] = float(z_3way)
            results['p_dissociation'] = float(p_3way)
            results['term_name'] = three_way_term

            if verbose:
                sig = "*" if p_3way < 0.05 else ""
                print(f"    3-way interaction (UCLA×Gender×Task):")
                print(f"      beta={beta_3way:.4f}, SE={se_3way:.4f}, z={z_3way:.3f}, p={p_3way:.4f}{sig}")

        # Also extract individual task interactions for reference
        # UCLA × Gender interaction for task1 (reference)
        ucla_gender_term = [
            p for p in model.params.index
            if 'z_ucla' in p and 'gender_male' in p and 'task' not in p
        ]
        if ucla_gender_term:
            results[f'beta_interaction_{task1}'] = float(model.params[ucla_gender_term[0]])
            results[f'p_interaction_{task1}'] = float(model.pvalues[ucla_gender_term[0]])

        # For task2, we need to add the 3-way interaction to the base interaction
        if ucla_gender_term and three_way_terms:
            base_int = model.params[ucla_gender_term[0]]
            three_way = model.params[three_way_terms[0]]
            results[f'beta_interaction_{task2}'] = float(base_int + three_way)

    except Exception as e:
        results['error'] = str(e)
        if verbose:
            print(f"    Model fitting error: {e}")

    return results


# =============================================================================
# ANALYSIS: DISSOCIATION TEST
# =============================================================================

def analyze_dissociation(verbose: bool = True) -> Dict:
    """
    Formally test the dissociation pattern between tasks.

    Uses stacked mixed model with 3-way interaction (UCLA × Gender × Task)
    to properly test whether UCLA×Gender effects differ between tasks,
    accounting for within-subject correlation.

    Tests whether UCLA x Gender interactions differ between:
    - WCST PE (male vulnerability)
    - Stroop interference (female vulnerability)

    Returns
    -------
    dict
        Dissociation test results
    """
    if verbose:
        print("\n" + "=" * 70)
        print("TASK-SPECIFIC GENDER DISSOCIATION ANALYSIS")
        print("(Stacked Mixed Model - 3-way Interaction)")
        print("=" * 70)

    df = load_gender_data(verbose=verbose)

    results = {}

    # Define task pairs for dissociation
    task_pairs = [
        ('pe_rate', 'stroop_interference', 'WCST PE vs Stroop Interference'),
        ('pe_rate', 'prp_bottleneck', 'WCST PE vs PRP Bottleneck'),
    ]

    for task1, task2, label in task_pairs:
        if task1 not in df.columns or task2 not in df.columns:
            continue

        if verbose:
            print(f"\n  {label}")
            print("  " + "-" * 50)

        # Use stacked mixed model for proper dissociation test
        dissoc_results = _test_dissociation_stacked(df, task1, task2, verbose=verbose)

        if 'error' not in dissoc_results:
            results[f'{label}_dissociation_z'] = dissoc_results.get('z_dissociation', np.nan)
            results[f'{label}_dissociation_p'] = dissoc_results.get('p_dissociation', np.nan)
            results[f'{label}_method'] = dissoc_results.get('method', 'stacked_mixed_model')
            results[f'{label}_n'] = dissoc_results.get('n_participants', np.nan)

            # Store individual interaction betas for reference
            if f'beta_interaction_{task1}' in dissoc_results:
                results[f'{label}_{task1}_interaction_beta'] = dissoc_results[f'beta_interaction_{task1}']
            if f'beta_interaction_{task2}' in dissoc_results:
                results[f'{label}_{task2}_interaction_beta'] = dissoc_results[f'beta_interaction_{task2}']

    if verbose:
        print("\n  DOUBLE DISSOCIATION SUMMARY:")
        print("  " + "-" * 50)
        print("    Pattern observed:")
        print("    - Males: WCST PE UCLA effect (higher perseverative errors)")
        print("    - Females: Stroop interference UCLA effect")
        print("    3-way interaction tests if these patterns differ significantly")

    output_file = OUTPUT_DIR / "dissociation_analysis.json"
    with open(output_file, 'w', encoding='utf-8') as f:
        json_results = {k: float(v) if isinstance(v, (np.floating, np.integer)) else v
                        for k, v in results.items()}
        json.dump(json_results, f, indent=2)

    if verbose:
        print(f"\n  Output: {output_file}")

    return results


# =============================================================================
# ANALYSIS: INTEGRATION
# =============================================================================

def analyze_integration(verbose: bool = True) -> Dict:
    """
    Comprehensive integration of gender double dissociation.

    Creates forest plot and summary statistics.

    Note: Effect sizes are reported as standardized_beta (not Cohen's d)
    because z_ucla is a continuous standardized predictor.

    Returns
    -------
    dict
        Integration results
    """
    import matplotlib.pyplot as plt

    if verbose:
        print("\n" + "=" * 70)
        print("GENDER DOUBLE DISSOCIATION INTEGRATION")
        print("=" * 70)

    df = load_gender_data(verbose=verbose)

    results = {
        'n_total': len(df),
        'n_male': (df['gender_male'] == 1).sum(),
        'n_female': (df['gender_male'] == 0).sum()
    }

    effect_data = []

    if verbose:
        print(f"\n  Sample: N={results['n_total']} (Male={results['n_male']}, Female={results['n_female']})")
        print("\n  Computing effect sizes (standardized beta)...")
        print("  " + "-" * 50)

    # Male WCST PE effect
    male_subset = df[df['gender_male'] == 1].dropna(
        subset=['z_ucla', 'pe_rate', 'z_dass_dep', 'z_dass_anx', 'z_dass_str', 'z_age']
    )

    if len(male_subset) >= 20:
        try:
            formula = "pe_rate ~ z_ucla + z_dass_dep + z_dass_anx + z_dass_str + z_age"
            model = smf.ols(formula, data=male_subset).fit(cov_type='HC3')

            beta = model.params.get('z_ucla', np.nan)
            se = model.bse.get('z_ucla', np.nan)
            p = model.pvalues.get('z_ucla', np.nan)
            t_stat = model.tvalues.get('z_ucla', np.nan)
            df_resid = model.df_resid

            # Standardized beta (z_ucla is already standardized, so beta is interpretable)
            # Also compute partial r for additional context
            partial_r = np.sqrt(t_stat**2 / (t_stat**2 + df_resid)) * np.sign(beta) if pd.notna(t_stat) else np.nan

            effect_data.append({
                'pattern': 'Male: WCST PE Rate',
                'domain': 'Cognitive Flexibility',
                'gender': 'Male',
                'beta': beta,
                'se': se,
                'p': p,
                'standardized_beta': beta,  # beta itself is standardized effect
                'partial_r': partial_r,
                'n': len(male_subset)
            })

            results['male_pe_beta'] = beta
            results['male_pe_p'] = p
            results['male_pe_standardized_beta'] = beta
            results['male_pe_partial_r'] = partial_r

            if verbose:
                sig = "*" if p < 0.05 else ""
                print(f"    Male WCST PE: beta={beta:.4f}, p={p:.4f}{sig}, partial_r={partial_r:.3f}")
        except Exception as e:
            if verbose:
                print(f"    Male WCST PE: Error - {e}")

    # Female Stroop effect
    female_subset = df[df['gender_male'] == 0].dropna(
        subset=['z_ucla', 'stroop_interference', 'z_dass_dep', 'z_dass_anx', 'z_dass_str', 'z_age']
    )

    if len(female_subset) >= 20:
        try:
            formula = "stroop_interference ~ z_ucla + z_dass_dep + z_dass_anx + z_dass_str + z_age"
            model = smf.ols(formula, data=female_subset).fit(cov_type='HC3')

            beta = model.params.get('z_ucla', np.nan)
            se = model.bse.get('z_ucla', np.nan)
            p = model.pvalues.get('z_ucla', np.nan)
            t_stat = model.tvalues.get('z_ucla', np.nan)
            df_resid = model.df_resid

            # Partial r
            partial_r = np.sqrt(t_stat**2 / (t_stat**2 + df_resid)) * np.sign(beta) if pd.notna(t_stat) else np.nan

            effect_data.append({
                'pattern': 'Female: Stroop Interference',
                'domain': 'Processing Speed',
                'gender': 'Female',
                'beta': beta,
                'se': se,
                'p': p,
                'standardized_beta': beta,
                'partial_r': partial_r,
                'n': len(female_subset)
            })

            results['female_stroop_beta'] = beta
            results['female_stroop_p'] = p
            results['female_stroop_standardized_beta'] = beta
            results['female_stroop_partial_r'] = partial_r

            if verbose:
                sig = "*" if p < 0.05 else ""
                print(f"    Female Stroop: beta={beta:.4f}, p={p:.4f}{sig}, partial_r={partial_r:.3f}")
        except Exception as e:
            if verbose:
                print(f"    Female Stroop: Error - {e}")

    # Save effect summary
    if effect_data:
        effect_df = pd.DataFrame(effect_data)
        effect_df.to_csv(OUTPUT_DIR / "double_dissociation_effects.csv", index=False, encoding='utf-8-sig')

        if verbose:
            print(f"\n  Effect summary saved: {OUTPUT_DIR / 'double_dissociation_effects.csv'}")

    # Create forest plot
    if len(effect_data) >= 2:
        try:
            plt.figure(figsize=(10, 6))
            plt.style.use('seaborn-v0_8-whitegrid')

            y_positions = list(range(len(effect_data)))
            colors = ['#1f77b4' if e['gender'] == 'Male' else '#d62728' for e in effect_data]

            for i, effect in enumerate(effect_data):
                beta = effect['beta']
                se = effect['se']

                if pd.notna(beta) and pd.notna(se):
                    ci_low = beta - 1.96 * se
                    ci_high = beta + 1.96 * se

                    plt.errorbar(beta, i, xerr=[[beta - ci_low], [ci_high - beta]],
                                fmt='o', markersize=10, capsize=5, color=colors[i],
                                elinewidth=2, capthick=2)

                    if effect['p'] < 0.05:
                        plt.text(beta + 0.02, i + 0.15, '*', fontsize=16,
                                fontweight='bold', color=colors[i])

            plt.axvline(x=0, color='gray', linestyle='--', alpha=0.7)

            plt.yticks(y_positions, [e['pattern'] for e in effect_data])
            plt.xlabel('Standardized beta (95% CI)', fontsize=12)
            plt.title('Gender-Specific UCLA - EF Effects\n(DASS-Controlled)', fontsize=14)

            from matplotlib.patches import Patch
            legend_elements = [
                Patch(facecolor='#1f77b4', label='Male'),
                Patch(facecolor='#d62728', label='Female')
            ]
            plt.legend(handles=legend_elements, loc='lower right')

            plt.tight_layout()
            plt.savefig(OUTPUT_DIR / "double_dissociation_forest.png", dpi=150, bbox_inches='tight')
            plt.close()

            if verbose:
                print(f"  Forest plot saved: {OUTPUT_DIR / 'double_dissociation_forest.png'}")
        except Exception as e:
            if verbose:
                print(f"  Forest plot error: {e}")

    # Summary
    if verbose:
        print("\n  DOUBLE DISSOCIATION SUMMARY")
        print("  " + "=" * 50)
        print("\n  Pattern:")
        print("    | Gender | Vulnerable Domain                |")
        print("    |--------|----------------------------------|")
        print("    | Male   | WCST PE (Cognitive Flexibility)  |")
        print("    | Female | Stroop (Processing Speed)        |")

        print("\n  Effect Size Note:")
        print("    - standardized_beta: regression coefficient with z-scored predictor")
        print("    - partial_r: partial correlation controlling for covariates")
        print("    - NOT Cohen's d (which requires categorical group comparison)")

        print("\n  Theoretical Interpretation:")
        print("    - Male loneliness -> Set-shifting/flexibility deficits")
        print("    - Female loneliness -> Information processing slowdown")
        print("    - Both effects independent of depression/anxiety/stress")

    # Save results
    output_file = OUTPUT_DIR / "double_dissociation_integration.json"
    with open(output_file, 'w', encoding='utf-8') as f:
        json_results = {k: float(v) if isinstance(v, (np.floating, np.integer)) else v
                        for k, v in results.items()}
        json.dump(json_results, f, indent=2)

    if verbose:
        print(f"\n  Output: {output_file}")

    return results


# =============================================================================
# RUNNER
# =============================================================================

def run(verbose: bool = True) -> Dict:
    """
    Run all double dissociation analyses.

    Returns
    -------
    dict
        Results from all analyses
    """
    results = {}

    try:
        results['dissociation'] = analyze_dissociation(verbose=verbose)
    except Exception as e:
        if verbose:
            print(f"  ERROR in dissociation: {e}")

    try:
        results['integration'] = analyze_integration(verbose=verbose)
    except Exception as e:
        if verbose:
            print(f"  ERROR in integration: {e}")

    return results


if __name__ == "__main__":
    run(verbose=True)
