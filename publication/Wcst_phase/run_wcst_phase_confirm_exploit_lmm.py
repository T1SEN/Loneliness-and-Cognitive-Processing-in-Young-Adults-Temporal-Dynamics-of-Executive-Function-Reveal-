from __future__ import annotations

import argparse
import sys
import warnings
from pathlib import Path

import numpy as np
import pandas as pd
import statsmodels.formula.api as smf
from statsmodels.tools.sm_exceptions import ConvergenceWarning

ROOT = Path(__file__).resolve().parents[2]
if str(ROOT) not in sys.path:
    sys.path.append(str(ROOT))

from publication.preprocessing.constants import get_results_dir
from publication.preprocessing.core import ensure_participant_id
from publication.preprocessing.surveys import load_dass_scores, load_participants, load_ucla_scores
from publication.preprocessing.wcst._shared import prepare_wcst_trials

from run_wcst_post_shift_error_log_ols import label_wcst_phases


def add_zscores(df: pd.DataFrame, cols: list[str]) -> pd.DataFrame:
    df = df.copy()
    for col in cols:
        if col not in df.columns:
            continue
        std = df[col].std()
        df[f"z_{col}"] = (df[col] - df[col].mean()) / std if std and np.isfinite(std) else np.nan
    return df


def load_base_data() -> pd.DataFrame:
    data_dir = get_results_dir("overall")
    participants = load_participants(data_dir)
    ucla = load_ucla_scores(data_dir).rename(columns={"ucla_total": "ucla_score"})
    dass = load_dass_scores(data_dir)

    base = participants.merge(ucla, on="participant_id", how="inner")
    base = base.merge(dass, on="participant_id", how="left")
    base["gender_male"] = base["gender"].map({"male": 1, "female": 0})
    return base


def load_qc_ids(task: str) -> set[str]:
    task_dir = get_results_dir(task)
    qc_ids_path = task_dir / "filtered_participant_ids.csv"
    if not qc_ids_path.exists():
        return set()
    qc_ids = pd.read_csv(qc_ids_path, encoding="utf-8-sig")
    qc_ids = ensure_participant_id(qc_ids)
    if "participant_id" not in qc_ids.columns:
        return set()
    return set(qc_ids["participant_id"].dropna().astype(str))


def _fit_mixedlm_with_warnings(
    formula: str,
    df: pd.DataFrame,
    re_formula: str,
    vc_formula: dict[str, str],
    method: str,
    reml: bool,
) -> tuple[object, list[str]]:
    warning_msgs: list[str] = []
    with warnings.catch_warnings(record=True) as caught:
        warnings.simplefilter("always", ConvergenceWarning)
        model = smf.mixedlm(
            formula,
            data=df,
            groups=df["participant_id"],
            re_formula=re_formula,
            vc_formula=vc_formula,
        )
        result = model.fit(reml=reml, method=method, maxiter=200)
    for warn in caught:
        if issubclass(warn.category, ConvergenceWarning):
            warning_msgs.append(str(warn.message))
    return result, warning_msgs


def fit_with_fallback(
    df: pd.DataFrame,
    formula: str,
    vc_formula: dict[str, str],
) -> tuple[object, dict[str, object], str | None, list[str]]:
    attempts = [
        {"re_formula": "1", "method": "lbfgs", "reml": False},
        {"re_formula": "1", "method": "powell", "reml": False},
        {"re_formula": "1", "method": "lbfgs", "reml": True},
        {"re_formula": "1", "method": "powell", "reml": True},
    ]
    last_error = None
    last_result = None
    last_attempt = attempts[-1]
    last_warnings: list[str] = []
    fallback_result = None
    fallback_attempt = None
    fallback_warnings: list[str] = []

    for attempt in attempts:
        try:
            result, warning_msgs = _fit_mixedlm_with_warnings(
                formula,
                df,
                attempt["re_formula"],
                vc_formula,
                attempt["method"],
                bool(attempt["reml"]),
            )
            last_result = result
            last_attempt = attempt
            last_warnings = warning_msgs
            if getattr(result, "converged", False):
                boundary_warning = any("boundary" in msg.lower() for msg in warning_msgs)
                hessian_warning = any("hessian" in msg.lower() and "not positive" in msg.lower() for msg in warning_msgs)
                if not boundary_warning and not hessian_warning:
                    return result, attempt, None, warning_msgs
                if fallback_result is None:
                    fallback_result = result
                    fallback_attempt = attempt
                    fallback_warnings = warning_msgs
        except Exception as exc:
            last_error = str(exc)

    if fallback_result is not None and fallback_attempt is not None:
        return fallback_result, fallback_attempt, None, fallback_warnings

    if last_result is None:
        raise RuntimeError(f"Phase LMM failed: {last_error}")
    return last_result, last_attempt, last_error or "not_converged", last_warnings


def _summarize_terms(result: object) -> pd.DataFrame:
    params = getattr(result, "params", {})
    bse = getattr(result, "bse", {})
    tvalues = getattr(result, "tvalues", {})
    pvalues = getattr(result, "pvalues", {})
    rows = []
    for term, beta in params.items():
        rows.append({
            "term": term,
            "beta": float(beta),
            "se": float(bse.get(term, np.nan)),
            "z": float(tvalues.get(term, np.nan)),
            "p": float(pvalues.get(term, np.nan)),
        })
    return pd.DataFrame(rows)


def main(confirm_len: int, include_errors: bool) -> None:
    output_dir = ROOT / "publication" / "data" / "outputs" / "analysis" / "wcst"
    output_dir.mkdir(parents=True, exist_ok=True)

    base = load_base_data()
    base = add_zscores(
        base,
        ["ucla_score", "dass_depression", "dass_anxiety", "dass_stress", "age"],
    )
    predictors = base[
        [
            "participant_id",
            "z_ucla_score",
            "z_dass_depression",
            "z_dass_anxiety",
            "z_dass_stress",
            "z_age",
            "gender_male",
        ]
    ].dropna()

    prepared = prepare_wcst_trials()
    wcst = prepared["wcst"]
    rt_col = prepared["rt_col"]
    trial_col = prepared["trial_col"]
    rule_col = prepared["rule_col"]
    if not isinstance(wcst, pd.DataFrame) or wcst.empty or rt_col is None or trial_col is None or rule_col is None:
        raise RuntimeError("WCST trials missing required columns.")

    qc_ids = load_qc_ids("wcst")
    if qc_ids:
        wcst = wcst[wcst["participant_id"].isin(qc_ids)]

    wcst["rt_ms"] = pd.to_numeric(wcst[rt_col], errors="coerce")
    wcst = wcst[wcst["rt_ms"].notna()]
    if "is_rt_valid" in wcst.columns:
        wcst = wcst[wcst["is_rt_valid"] == True]

    wcst["rule"] = wcst[rule_col].astype(str).str.lower().replace({"color": "colour"})
    wcst = label_wcst_phases(wcst, rule_col="rule", trial_col=trial_col, confirm_len=confirm_len)
    wcst = wcst.dropna(subset=["phase", "category_num"])
    if not include_errors:
        wcst = wcst[wcst["correct"].astype(bool)]

    wcst = wcst[wcst["phase"].isin(["confirmation", "exploitation"])].copy()
    if wcst.empty:
        raise RuntimeError("No confirmation/exploitation trials after filtering.")

    wcst["phase_code"] = wcst["phase"].map({"confirmation": 0.0, "exploitation": 1.0})
    wcst["log_rt"] = np.where(wcst["rt_ms"] > 0, np.log(wcst["rt_ms"]), np.nan)
    wcst = wcst.dropna(subset=["log_rt", "phase_code"])

    df = wcst.merge(predictors, on="participant_id", how="inner")
    if df.empty:
        raise RuntimeError("No WCST trials available after merging predictors.")

    df["participant_category"] = df["participant_id"].astype(str) + "_c" + df["category_num"].astype(int).astype(str)

    formula = (
        "log_rt ~ phase_code * z_ucla_score + "
        "z_dass_depression + z_dass_anxiety + z_dass_stress + z_age + gender_male"
    )
    vc_formula = {"participant_category": "0 + C(participant_category)"}

    result, attempt, fit_note, warnings_list = fit_with_fallback(df, formula, vc_formula)
    warning_text = " | ".join(warnings_list)
    boundary_warning = any("boundary" in msg.lower() for msg in warnings_list)

    meta = {
        "confirm_len": int(confirm_len),
        "include_errors": bool(include_errors),
        "n_trials": int(len(df)),
        "n_participants": int(df["participant_id"].nunique()),
        "re_formula": attempt["re_formula"],
        "method": attempt["method"],
        "reml": bool(attempt.get("reml", False)),
        "converged": bool(getattr(result, "converged", False)),
        "fit_note": fit_note,
        "warning_count": len(warnings_list),
        "boundary_warning": boundary_warning,
        "warning_msg": warning_text,
        "llf": float(getattr(result, "llf", np.nan)),
        "aic": float(getattr(result, "aic", np.nan)),
        "bic": float(getattr(result, "bic", np.nan)),
        "formula": formula,
        "phase_coding": "confirmation=0, exploitation=1",
    }

    suffix = f"m{confirm_len}"
    err_tag = "alltrials" if include_errors else "correct"
    meta_path = output_dir / f"wcst_phase_confirm_exploit_lmm_{suffix}_{err_tag}_meta.csv"
    pd.DataFrame([meta]).to_csv(meta_path, index=False, encoding="utf-8-sig")

    coef_df = _summarize_terms(result)
    coef_path = output_dir / f"wcst_phase_confirm_exploit_lmm_{suffix}_{err_tag}_coeffs.csv"
    coef_df.to_csv(coef_path, index=False, encoding="utf-8-sig")

    print(f"Saved: {meta_path}")
    print(f"Saved: {coef_path}")


if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument("--confirm-len", type=int, default=3)
    parser.add_argument("--include-errors", action="store_true")
    args = parser.parse_args()
    main(args.confirm_len, args.include_errors)
