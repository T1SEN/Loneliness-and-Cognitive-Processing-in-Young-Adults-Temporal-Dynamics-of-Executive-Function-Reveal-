from __future__ import annotations

import argparse
import sys
import warnings
from pathlib import Path

import numpy as np
import pandas as pd
import statsmodels.formula.api as smf
from scipy import stats
from statsmodels.tools.sm_exceptions import ConvergenceWarning

ROOT = Path(__file__).resolve().parents[2]
if str(ROOT) not in sys.path:
    sys.path.append(str(ROOT))

from publication.preprocessing.constants import get_results_dir
from publication.preprocessing.core import ensure_participant_id
from publication.preprocessing.surveys import load_dass_scores, load_participants, load_ucla_scores
from publication.preprocessing.wcst._shared import prepare_wcst_trials

from run_wcst_post_shift_error_log_ols import label_wcst_phases


def add_zscores(df: pd.DataFrame, cols: list[str]) -> pd.DataFrame:
    df = df.copy()
    for col in cols:
        if col not in df.columns:
            continue
        std = df[col].std()
        df[f"z_{col}"] = (df[col] - df[col].mean()) / std if std and np.isfinite(std) else np.nan
    return df


def load_base_data() -> pd.DataFrame:
    data_dir = get_results_dir("overall")
    participants = load_participants(data_dir)
    ucla = load_ucla_scores(data_dir).rename(columns={"ucla_total": "ucla_score"})
    dass = load_dass_scores(data_dir)

    base = participants.merge(ucla, on="participant_id", how="inner")
    base = base.merge(dass, on="participant_id", how="left")
    base["gender_male"] = base["gender"].map({"male": 1, "female": 0})
    return base


def load_qc_ids(task: str) -> set[str]:
    task_dir = get_results_dir(task)
    qc_ids_path = task_dir / "filtered_participant_ids.csv"
    if not qc_ids_path.exists():
        return set()
    qc_ids = pd.read_csv(qc_ids_path, encoding="utf-8-sig")
    qc_ids = ensure_participant_id(qc_ids)
    if "participant_id" not in qc_ids.columns:
        return set()
    return set(qc_ids["participant_id"].dropna().astype(str))


def _fit_mixedlm_with_warnings(
    formula: str,
    df: pd.DataFrame,
    re_formula: str,
    vc_formula: dict[str, str],
    method: str,
    reml: bool,
) -> tuple[object, list[str]]:
    warning_msgs: list[str] = []
    with warnings.catch_warnings(record=True) as caught:
        warnings.simplefilter("always", ConvergenceWarning)
        model = smf.mixedlm(
            formula,
            data=df,
            groups=df["participant_id"],
            re_formula=re_formula,
            vc_formula=vc_formula,
        )
        result = model.fit(reml=reml, method=method, maxiter=200)
    for warn in caught:
        if issubclass(warn.category, ConvergenceWarning):
            warning_msgs.append(str(warn.message))
    return result, warning_msgs


def fit_with_fallback(
    df: pd.DataFrame,
    formula: str,
    vc_formula: dict[str, str],
) -> tuple[object, dict[str, object], str | None, list[str]]:
    attempts = [
        {"re_formula": "1", "method": "lbfgs", "reml": False},
        {"re_formula": "1", "method": "powell", "reml": False},
        {"re_formula": "1", "method": "lbfgs", "reml": True},
        {"re_formula": "1", "method": "powell", "reml": True},
    ]
    last_error = None
    last_result = None
    last_attempt = attempts[-1]
    last_warnings: list[str] = []
    fallback_result = None
    fallback_attempt = None
    fallback_warnings: list[str] = []

    for attempt in attempts:
        try:
            result, warning_msgs = _fit_mixedlm_with_warnings(
                formula,
                df,
                attempt["re_formula"],
                vc_formula,
                attempt["method"],
                bool(attempt["reml"]),
            )
            last_result = result
            last_attempt = attempt
            last_warnings = warning_msgs
            if getattr(result, "converged", False):
                boundary_warning = any("boundary" in msg.lower() for msg in warning_msgs)
                hessian_warning = any("hessian" in msg.lower() and "not positive" in msg.lower() for msg in warning_msgs)
                if not boundary_warning and not hessian_warning:
                    return result, attempt, None, warning_msgs
                if fallback_result is None:
                    fallback_result = result
                    fallback_attempt = attempt
                    fallback_warnings = warning_msgs
        except Exception as exc:
            last_error = str(exc)

    if fallback_result is not None and fallback_attempt is not None:
        return fallback_result, fallback_attempt, None, fallback_warnings

    if last_result is None:
        raise RuntimeError(f"LMM failed: {last_error}")
    return last_result, last_attempt, last_error or "not_converged", last_warnings


def _summarize_terms(result: object) -> pd.DataFrame:
    params = getattr(result, "params", {})
    bse = getattr(result, "bse", {})
    tvalues = getattr(result, "tvalues", {})
    pvalues = getattr(result, "pvalues", {})
    rows = []
    for term, beta in params.items():
        rows.append({
            "term": term,
            "beta": float(beta),
            "se": float(bse.get(term, np.nan)),
            "z": float(tvalues.get(term, np.nan)),
            "p": float(pvalues.get(term, np.nan)),
        })
    return pd.DataFrame(rows)


def _simple_slope(result: object, term_a: str, term_b: str | None = None) -> tuple[float, float, float, float]:
    params = result.params
    cov = result.cov_params()
    beta_a = float(params.get(term_a, np.nan))
    if term_b is None:
        se = float(np.sqrt(cov.loc[term_a, term_a]))
        z = beta_a / se if se else np.nan
        p = 2 * (1 - stats.norm.cdf(abs(z))) if np.isfinite(z) else np.nan
        return beta_a, se, z, p

    beta_b = float(params.get(term_b, np.nan))
    beta = beta_a + beta_b
    var = cov.loc[term_a, term_a] + cov.loc[term_b, term_b] + 2 * cov.loc[term_a, term_b]
    se = float(np.sqrt(var)) if var >= 0 else np.nan
    z = beta / se if se else np.nan
    p = 2 * (1 - stats.norm.cdf(abs(z))) if np.isfinite(z) else np.nan
    return beta, se, z, p


def main(confirm_len: int, include_errors: bool) -> None:
    output_dir = ROOT / "publication" / "data" / "outputs" / "analysis" / "wcst"
    output_dir.mkdir(parents=True, exist_ok=True)

    base = load_base_data()
    base = add_zscores(
        base,
        ["ucla_score", "dass_depression", "dass_anxiety", "dass_stress", "age"],
    )
    predictors = base[
        [
            "participant_id",
            "z_ucla_score",
            "z_dass_depression",
            "z_dass_anxiety",
            "z_dass_stress",
            "z_age",
            "gender_male",
        ]
    ].dropna()

    prepared = prepare_wcst_trials()
    wcst = prepared["wcst"]
    rt_col = prepared["rt_col"]
    trial_col = prepared["trial_col"]
    rule_col = prepared["rule_col"]
    if not isinstance(wcst, pd.DataFrame) or wcst.empty or rt_col is None or trial_col is None or rule_col is None:
        raise RuntimeError("WCST trials missing required columns.")

    qc_ids = load_qc_ids("wcst")
    if qc_ids:
        wcst = wcst[wcst["participant_id"].isin(qc_ids)]

    wcst["rt_ms"] = pd.to_numeric(wcst[rt_col], errors="coerce")
    wcst = wcst[wcst["rt_ms"].notna()]
    if "is_rt_valid" in wcst.columns:
        wcst = wcst[wcst["is_rt_valid"] == True]

    wcst["rule"] = wcst[rule_col].astype(str).str.lower().replace({"color": "colour"})
    wcst = label_wcst_phases(wcst, rule_col="rule", trial_col=trial_col, confirm_len=confirm_len)
    wcst = wcst.dropna(subset=["phase", "category_num"])
    if not include_errors:
        wcst = wcst[wcst["correct"].astype(bool)]

    wcst = wcst[wcst["phase"].isin(["confirmation", "exploitation"])].copy()
    if wcst.empty:
        raise RuntimeError("No confirmation/exploitation trials after filtering.")

    wcst["phase_code"] = wcst["phase"].map({"confirmation": 0.0, "exploitation": 1.0})
    wcst["log_rt"] = np.where(wcst["rt_ms"] > 0, np.log(wcst["rt_ms"]), np.nan)
    wcst = wcst.dropna(subset=["log_rt", "phase_code"])

    df = wcst.merge(predictors, on="participant_id", how="inner")
    if df.empty:
        raise RuntimeError("No WCST trials available after merging predictors.")

    df["participant_category"] = df["participant_id"].astype(str) + "_c" + df["category_num"].astype(int).astype(str)
    vc_formula = {"participant_category": "0 + C(participant_category)"}

    # 1) Simple slopes on log_rt model (phase x ucla)
    formula_log = (
        "log_rt ~ phase_code * z_ucla_score + "
        "z_dass_depression + z_dass_anxiety + z_dass_stress + z_age + gender_male"
    )
    result_log, attempt_log, fit_note_log, warn_log = fit_with_fallback(df, formula_log, vc_formula)
    warning_text_log = " | ".join(warn_log)
    boundary_warning_log = any("boundary" in msg.lower() for msg in warn_log)

    b_conf, se_conf, z_conf, p_conf = _simple_slope(result_log, "z_ucla_score")
    b_expl, se_expl, z_expl, p_expl = _simple_slope(result_log, "z_ucla_score", "phase_code:z_ucla_score")

    posthoc = pd.DataFrame([
        {
            "confirm_len": int(confirm_len),
            "include_errors": bool(include_errors),
            "model": "log_rt",
            "slope": "ucla_confirmation",
            "beta": b_conf,
            "se": se_conf,
            "z": z_conf,
            "p": p_conf,
        },
        {
            "confirm_len": int(confirm_len),
            "include_errors": bool(include_errors),
            "model": "log_rt",
            "slope": "ucla_exploitation",
            "beta": b_expl,
            "se": se_expl,
            "z": z_expl,
            "p": p_expl,
        },
    ])

    err_tag = "alltrials" if include_errors else "correct"
    suffix = f"m{confirm_len}"
    posthoc_path = output_dir / f"wcst_phase_confirm_exploit_lmm_posthoc_{suffix}_{err_tag}.csv"
    posthoc.to_csv(posthoc_path, index=False, encoding="utf-8-sig")

    meta_log = {
        "confirm_len": int(confirm_len),
        "include_errors": bool(include_errors),
        "model": "log_rt",
        "n_trials": int(len(df)),
        "n_participants": int(df["participant_id"].nunique()),
        "re_formula": attempt_log["re_formula"],
        "method": attempt_log["method"],
        "reml": bool(attempt_log.get("reml", False)),
        "converged": bool(getattr(result_log, "converged", False)),
        "fit_note": fit_note_log,
        "warning_count": len(warn_log),
        "boundary_warning": boundary_warning_log,
        "warning_msg": warning_text_log,
        "llf": float(getattr(result_log, "llf", np.nan)),
        "aic": float(getattr(result_log, "aic", np.nan)),
        "bic": float(getattr(result_log, "bic", np.nan)),
        "formula": formula_log,
    }
    meta_log_path = output_dir / f"wcst_phase_confirm_exploit_lmm_{suffix}_{err_tag}_meta.csv"
    coef_log_path = output_dir / f"wcst_phase_confirm_exploit_lmm_{suffix}_{err_tag}_coeffs.csv"
    pd.DataFrame([meta_log]).to_csv(meta_log_path, index=False, encoding="utf-8-sig")
    _summarize_terms(result_log).to_csv(coef_log_path, index=False, encoding="utf-8-sig")

    # 2) Raw RT LMM (same structure)
    formula_raw = (
        "rt_ms ~ phase_code * z_ucla_score + "
        "z_dass_depression + z_dass_anxiety + z_dass_stress + z_age + gender_male"
    )
    result_raw, attempt_raw, fit_note_raw, warn_raw = fit_with_fallback(df, formula_raw, vc_formula)
    warning_text_raw = " | ".join(warn_raw)
    boundary_warning_raw = any("boundary" in msg.lower() for msg in warn_raw)

    meta_raw = {
        "confirm_len": int(confirm_len),
        "include_errors": bool(include_errors),
        "model": "raw_rt",
        "n_trials": int(len(df)),
        "n_participants": int(df["participant_id"].nunique()),
        "re_formula": attempt_raw["re_formula"],
        "method": attempt_raw["method"],
        "reml": bool(attempt_raw.get("reml", False)),
        "converged": bool(getattr(result_raw, "converged", False)),
        "fit_note": fit_note_raw,
        "warning_count": len(warn_raw),
        "boundary_warning": boundary_warning_raw,
        "warning_msg": warning_text_raw,
        "llf": float(getattr(result_raw, "llf", np.nan)),
        "aic": float(getattr(result_raw, "aic", np.nan)),
        "bic": float(getattr(result_raw, "bic", np.nan)),
        "formula": formula_raw,
    }
    meta_raw_path = output_dir / f"wcst_phase_confirm_exploit_lmm_raw_{suffix}_{err_tag}_meta.csv"
    coef_raw_path = output_dir / f"wcst_phase_confirm_exploit_lmm_raw_{suffix}_{err_tag}_coeffs.csv"
    pd.DataFrame([meta_raw]).to_csv(meta_raw_path, index=False, encoding="utf-8-sig")
    _summarize_terms(result_raw).to_csv(coef_raw_path, index=False, encoding="utf-8-sig")

    # 3) Confirmation-only LMM (log RT)
    df_conf = df[df["phase_code"] == 0.0].copy()
    formula_conf = (
        "log_rt ~ z_ucla_score + "
        "z_dass_depression + z_dass_anxiety + z_dass_stress + z_age + gender_male"
    )
    result_conf, attempt_conf, fit_note_conf, warn_conf = fit_with_fallback(df_conf, formula_conf, vc_formula)
    warning_text_conf = " | ".join(warn_conf)
    boundary_warning_conf = any("boundary" in msg.lower() for msg in warn_conf)

    meta_conf = {
        "confirm_len": int(confirm_len),
        "include_errors": bool(include_errors),
        "model": "confirmation_only_log_rt",
        "n_trials": int(len(df_conf)),
        "n_participants": int(df_conf["participant_id"].nunique()),
        "re_formula": attempt_conf["re_formula"],
        "method": attempt_conf["method"],
        "reml": bool(attempt_conf.get("reml", False)),
        "converged": bool(getattr(result_conf, "converged", False)),
        "fit_note": fit_note_conf,
        "warning_count": len(warn_conf),
        "boundary_warning": boundary_warning_conf,
        "warning_msg": warning_text_conf,
        "llf": float(getattr(result_conf, "llf", np.nan)),
        "aic": float(getattr(result_conf, "aic", np.nan)),
        "bic": float(getattr(result_conf, "bic", np.nan)),
        "formula": formula_conf,
    }
    meta_conf_path = output_dir / f"wcst_phase_confirmation_only_lmm_{suffix}_{err_tag}_meta.csv"
    coef_conf_path = output_dir / f"wcst_phase_confirmation_only_lmm_{suffix}_{err_tag}_coeffs.csv"
    pd.DataFrame([meta_conf]).to_csv(meta_conf_path, index=False, encoding="utf-8-sig")
    _summarize_terms(result_conf).to_csv(coef_conf_path, index=False, encoding="utf-8-sig")

    print(f"Saved: {posthoc_path}")
    print(f"Saved: {meta_log_path}")
    print(f"Saved: {coef_log_path}")
    print(f"Saved: {meta_raw_path}")
    print(f"Saved: {coef_raw_path}")
    print(f"Saved: {meta_conf_path}")
    print(f"Saved: {coef_conf_path}")


if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument("--confirm-len", type=int, default=3)
    parser.add_argument("--include-errors", action="store_true")
    args = parser.parse_args()
    main(args.confirm_len, args.include_errors)
